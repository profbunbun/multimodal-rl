Help on package optuna:

NAME
    optuna

PACKAGE CONTENTS
    _callbacks
    _convert_positional_args
    _deprecated
    _experimental
    _hypervolume (package)
    _imports
    _transform
    _typing
    artifacts (package)
    cli
    distributions
    exceptions
    importance (package)
    integration (package)
    logging
    multi_objective (package)
    progress_bar
    pruners (package)
    samplers (package)
    search_space (package)
    storages (package)
    study (package)
    terminator (package)
    testing (package)
    trial (package)
    version
    visualization (package)

CLASSES
    builtins.object
        optuna.study.study.Study
    optuna.exceptions.OptunaError(builtins.Exception)
        optuna.exceptions.TrialPruned
    optuna.trial._base.BaseTrial(abc.ABC)
        optuna.trial._trial.Trial
    
    class Study(builtins.object)
     |  Study(study_name: 'str', storage: 'str | storages.BaseStorage', sampler: "'samplers.BaseSampler' | None" = None, pruner: 'pruners.BasePruner | None' = None) -> 'None'
     |  
     |  A study corresponds to an optimization task, i.e., a set of trials.
     |  
     |  This object provides interfaces to run a new :class:`~optuna.trial.Trial`, access trials'
     |  history, set/get user-defined attributes of the study itself.
     |  
     |  Note that the direct use of this constructor is not recommended.
     |  To create and load a study, please refer to the documentation of
     |  :func:`~optuna.study.create_study` and :func:`~optuna.study.load_study` respectively.
     |  
     |  Methods defined here:
     |  
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |  
     |  __init__(self, study_name: 'str', storage: 'str | storages.BaseStorage', sampler: "'samplers.BaseSampler' | None" = None, pruner: 'pruners.BasePruner | None' = None) -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  add_trial(self, trial: 'FrozenTrial') -> 'None'
     |      Add trial to study.
     |      
     |      The trial is validated before being added.
     |      
     |      Example:
     |      
     |          .. testcode::
     |      
     |              import optuna
     |              from optuna.distributions import FloatDistribution
     |      
     |      
     |              def objective(trial):
     |                  x = trial.suggest_float("x", 0, 10)
     |                  return x**2
     |      
     |      
     |              study = optuna.create_study()
     |              assert len(study.trials) == 0
     |      
     |              trial = optuna.trial.create_trial(
     |                  params={"x": 2.0},
     |                  distributions={"x": FloatDistribution(0, 10)},
     |                  value=4.0,
     |              )
     |      
     |              study.add_trial(trial)
     |              assert len(study.trials) == 1
     |      
     |              study.optimize(objective, n_trials=3)
     |              assert len(study.trials) == 4
     |      
     |              other_study = optuna.create_study()
     |      
     |              for trial in study.trials:
     |                  other_study.add_trial(trial)
     |              assert len(other_study.trials) == len(study.trials)
     |      
     |              other_study.optimize(objective, n_trials=2)
     |              assert len(other_study.trials) == len(study.trials) + 2
     |      
     |      .. seealso::
     |      
     |          This method should in general be used to add already evaluated trials
     |          (``trial.state.is_finished() == True``). To queue trials for evaluation,
     |          please refer to :func:`~optuna.study.Study.enqueue_trial`.
     |      
     |      .. seealso::
     |      
     |          See :func:`~optuna.trial.create_trial` for how to create trials.
     |      
     |      .. seealso::
     |          Please refer to :ref:`add_trial_tutorial` for the tutorial of specifying
     |          hyperparameters with the evaluated value manually.
     |      
     |      Args:
     |          trial: Trial to add.
     |  
     |  add_trials(self, trials: 'Iterable[FrozenTrial]') -> 'None'
     |      Add trials to study.
     |      
     |      The trials are validated before being added.
     |      
     |      Example:
     |      
     |          .. testcode::
     |      
     |              import optuna
     |      
     |      
     |              def objective(trial):
     |                  x = trial.suggest_float("x", 0, 10)
     |                  return x**2
     |      
     |      
     |              study = optuna.create_study()
     |              study.optimize(objective, n_trials=3)
     |              assert len(study.trials) == 3
     |      
     |              other_study = optuna.create_study()
     |              other_study.add_trials(study.trials)
     |              assert len(other_study.trials) == len(study.trials)
     |      
     |              other_study.optimize(objective, n_trials=2)
     |              assert len(other_study.trials) == len(study.trials) + 2
     |      
     |      .. seealso::
     |      
     |          See :func:`~optuna.study.Study.add_trial` for addition of each trial.
     |      
     |      Args:
     |          trials: Trials to add.
     |  
     |  ask(self, fixed_distributions: 'dict[str, BaseDistribution] | None' = None) -> 'trial_module.Trial'
     |      Create a new trial from which hyperparameters can be suggested.
     |      
     |      This method is part of an alternative to :func:`~optuna.study.Study.optimize` that allows
     |      controlling the lifetime of a trial outside the scope of ``func``. Each call to this
     |      method should be followed by a call to :func:`~optuna.study.Study.tell` to finish the
     |      created trial.
     |      
     |      .. seealso::
     |      
     |          The :ref:`ask_and_tell` tutorial provides use-cases with examples.
     |      
     |      Example:
     |      
     |          Getting the trial object with the :func:`~optuna.study.Study.ask` method.
     |      
     |          .. testcode::
     |      
     |              import optuna
     |      
     |      
     |              study = optuna.create_study()
     |      
     |              trial = study.ask()
     |      
     |              x = trial.suggest_float("x", -1, 1)
     |      
     |              study.tell(trial, x**2)
     |      
     |      Example:
     |      
     |          Passing previously defined distributions to the :func:`~optuna.study.Study.ask`
     |          method.
     |      
     |          .. testcode::
     |      
     |              import optuna
     |      
     |      
     |              study = optuna.create_study()
     |      
     |              distributions = {
     |                  "optimizer": optuna.distributions.CategoricalDistribution(["adam", "sgd"]),
     |                  "lr": optuna.distributions.FloatDistribution(0.0001, 0.1, log=True),
     |              }
     |      
     |              # You can pass the distributions previously defined.
     |              trial = study.ask(fixed_distributions=distributions)
     |      
     |              # `optimizer` and `lr` are already suggested and accessible with `trial.params`.
     |              assert "optimizer" in trial.params
     |              assert "lr" in trial.params
     |      
     |      Args:
     |          fixed_distributions:
     |              A dictionary containing the parameter names and parameter's distributions. Each
     |              parameter in this dictionary is automatically suggested for the returned trial,
     |              even when the suggest method is not explicitly invoked by the user. If this
     |              argument is set to :obj:`None`, no parameter is automatically suggested.
     |      
     |      Returns:
     |          A :class:`~optuna.trial.Trial`.
     |  
     |  enqueue_trial(self, params: 'dict[str, Any]', user_attrs: 'dict[str, Any] | None' = None, skip_if_exists: 'bool' = False) -> 'None'
     |      Enqueue a trial with given parameter values.
     |      
     |      You can fix the next sampling parameters which will be evaluated in your
     |      objective function.
     |      
     |      Example:
     |      
     |          .. testcode::
     |      
     |              import optuna
     |      
     |      
     |              def objective(trial):
     |                  x = trial.suggest_float("x", 0, 10)
     |                  return x**2
     |      
     |      
     |              study = optuna.create_study()
     |              study.enqueue_trial({"x": 5})
     |              study.enqueue_trial({"x": 0}, user_attrs={"memo": "optimal"})
     |              study.optimize(objective, n_trials=2)
     |      
     |              assert study.trials[0].params == {"x": 5}
     |              assert study.trials[1].params == {"x": 0}
     |              assert study.trials[1].user_attrs == {"memo": "optimal"}
     |      
     |      Args:
     |          params:
     |              Parameter values to pass your objective function.
     |          user_attrs:
     |              A dictionary of user-specific attributes other than ``params``.
     |          skip_if_exists:
     |              When :obj:`True`, prevents duplicate trials from being enqueued again.
     |      
     |              .. note::
     |                  This method might produce duplicated trials if called simultaneously
     |                  by multiple processes at the same time with same ``params`` dict.
     |      
     |      .. seealso::
     |      
     |          Please refer to :ref:`enqueue_trial_tutorial` for the tutorial of specifying
     |          hyperparameters manually.
     |  
     |  get_trials(self, deepcopy: 'bool' = True, states: 'Container[TrialState] | None' = None) -> 'list[FrozenTrial]'
     |      Return all trials in the study.
     |      
     |      The returned trials are ordered by trial number.
     |      
     |      .. seealso::
     |          See :attr:`~optuna.study.Study.trials` for related property.
     |      
     |      Example:
     |          .. testcode::
     |      
     |              import optuna
     |      
     |      
     |              def objective(trial):
     |                  x = trial.suggest_float("x", -1, 1)
     |                  return x**2
     |      
     |      
     |              study = optuna.create_study()
     |              study.optimize(objective, n_trials=3)
     |      
     |              trials = study.get_trials()
     |              assert len(trials) == 3
     |      Args:
     |          deepcopy:
     |              Flag to control whether to apply ``copy.deepcopy()`` to the trials.
     |              Note that if you set the flag to :obj:`False`, you shouldn't mutate
     |              any fields of the returned trial. Otherwise the internal state of
     |              the study may corrupt and unexpected behavior may happen.
     |          states:
     |              Trial states to filter on. If :obj:`None`, include all states.
     |      
     |      Returns:
     |          A list of :class:`~optuna.trial.FrozenTrial` objects.
     |  
     |  optimize(self, func: 'ObjectiveFuncType', n_trials: 'int | None' = None, timeout: 'float | None' = None, n_jobs: 'int' = 1, catch: 'Iterable[type[Exception]] | type[Exception]' = (), callbacks: "list[Callable[['Study', FrozenTrial], None]] | None" = None, gc_after_trial: 'bool' = False, show_progress_bar: 'bool' = False) -> 'None'
     |      Optimize an objective function.
     |      
     |      Optimization is done by choosing a suitable set of hyperparameter values from a given
     |      range. Uses a sampler which implements the task of value suggestion based on a specified
     |      distribution. The sampler is specified in :func:`~optuna.study.create_study` and the
     |      default choice for the sampler is TPE.
     |      See also :class:`~optuna.samplers.TPESampler` for more details on 'TPE'.
     |      
     |      Optimization will be stopped when receiving a termination signal such as SIGINT and
     |      SIGTERM. Unlike other signals, a trial is automatically and cleanly failed when receiving
     |      SIGINT (Ctrl+C). If ``n_jobs`` is greater than one or if another signal than SIGINT
     |      is used, the interrupted trial state won't be properly updated.
     |      
     |      Example:
     |      
     |          .. testcode::
     |      
     |              import optuna
     |      
     |      
     |              def objective(trial):
     |                  x = trial.suggest_float("x", -1, 1)
     |                  return x**2
     |      
     |      
     |              study = optuna.create_study()
     |              study.optimize(objective, n_trials=3)
     |      
     |      Args:
     |          func:
     |              A callable that implements objective function.
     |          n_trials:
     |              The number of trials for each process. :obj:`None` represents no limit in terms of
     |              the number of trials. The study continues to create trials until the number of
     |              trials reaches ``n_trials``, ``timeout`` period elapses,
     |              :func:`~optuna.study.Study.stop` is called, or a termination signal such as
     |              SIGTERM or Ctrl+C is received.
     |      
     |              .. seealso::
     |                  :class:`optuna.study.MaxTrialsCallback` can ensure how many times trials
     |                  will be performed across all processes.
     |          timeout:
     |              Stop study after the given number of second(s). :obj:`None` represents no limit in
     |              terms of elapsed time. The study continues to create trials until the number of
     |              trials reaches ``n_trials``, ``timeout`` period elapses,
     |              :func:`~optuna.study.Study.stop` is called or, a termination signal such as
     |              SIGTERM or Ctrl+C is received.
     |          n_jobs:
     |              The number of parallel jobs. If this argument is set to ``-1``, the number is
     |              set to CPU count.
     |      
     |              .. note::
     |                  ``n_jobs`` allows parallelization using :obj:`threading` and may suffer from
     |                  `Python's GIL <https://wiki.python.org/moin/GlobalInterpreterLock>`_.
     |                  It is recommended to use :ref:`process-based parallelization<distributed>`
     |                  if ``func`` is CPU bound.
     |      
     |          catch:
     |              A study continues to run even when a trial raises one of the exceptions specified
     |              in this argument. Default is an empty tuple, i.e. the study will stop for any
     |              exception except for :class:`~optuna.exceptions.TrialPruned`.
     |          callbacks:
     |              List of callback functions that are invoked at the end of each trial. Each function
     |              must accept two parameters with the following types in this order:
     |              :class:`~optuna.study.Study` and :class:`~optuna.trial.FrozenTrial`.
     |      
     |              .. seealso::
     |      
     |                  See the tutorial of :ref:`optuna_callback` for how to use and implement
     |                  callback functions.
     |      
     |          gc_after_trial:
     |              Flag to determine whether to automatically run garbage collection after each trial.
     |              Set to :obj:`True` to run the garbage collection, :obj:`False` otherwise.
     |              When it runs, it runs a full collection by internally calling :func:`gc.collect`.
     |              If you see an increase in memory consumption over several trials, try setting this
     |              flag to :obj:`True`.
     |      
     |              .. seealso::
     |      
     |                  :ref:`out-of-memory-gc-collect`
     |      
     |          show_progress_bar:
     |              Flag to show progress bars or not. To disable progress bar, set this :obj:`False`.
     |              Currently, progress bar is experimental feature and disabled
     |              when ``n_trials`` is :obj:`None`, ``timeout`` is not :obj:`None`, and
     |              ``n_jobs`` :math:`\ne 1`.
     |      
     |      Raises:
     |          RuntimeError:
     |              If nested invocation of this method occurs.
     |  
     |  set_metric_names(self, metric_names: 'list[str]') -> 'None'
     |      Set metric names.
     |      
     |      This method names each dimension of the returned values of the objective function.
     |      It is particularly useful in multi-objective optimization. The metric names are
     |      mainly referenced by the visualization functions.
     |      
     |      Example:
     |      
     |          .. testcode::
     |      
     |              import optuna
     |              import pandas
     |      
     |      
     |              def objective(trial):
     |                  x = trial.suggest_float("x", 0, 10)
     |                  return x**2, x + 1
     |      
     |      
     |              study = optuna.create_study(directions=["minimize", "minimize"])
     |              study.set_metric_names(["x**2", "x+1"])
     |              study.optimize(objective, n_trials=3)
     |      
     |              df = study.trials_dataframe(multi_index=True)
     |              assert isinstance(df, pandas.DataFrame)
     |              assert list(df.get("values").keys()) == ["x**2", "x+1"]
     |      
     |      .. seealso::
     |          The names set by this method are used in :meth:`~optuna.study.Study.trials_dataframe`
     |          and :func:`~optuna.visualization.plot_pareto_front`.
     |      
     |      Args:
     |          metric_names: A list of metric names for the objective function.
     |      
     |      .. note::
     |          Added in v3.2.0 as an experimental feature. The interface may change in newer versions
     |          without prior notice. See https://github.com/optuna/optuna/releases/tag/v3.2.0.
     |  
     |  set_system_attr(self, key: 'str', value: 'Any') -> 'None'
     |      Set a system attribute to the study.
     |      
     |      Note that Optuna internally uses this method to save system messages. Please use
     |      :func:`~optuna.study.Study.set_user_attr` to set users' attributes.
     |      
     |      Args:
     |          key: A key string of the attribute.
     |          value: A value of the attribute. The value should be JSON serializable.
     |      
     |      .. warning::
     |          Deprecated in v3.1.0. This feature will be removed in the future. The removal of this
     |          feature is currently scheduled for v5.0.0, but this schedule is subject to change.
     |          See https://github.com/optuna/optuna/releases/tag/v3.1.0.
     |  
     |  set_user_attr(self, key: 'str', value: 'Any') -> 'None'
     |      Set a user attribute to the study.
     |      
     |      .. seealso::
     |      
     |          See :attr:`~optuna.study.Study.user_attrs` for related attribute.
     |      
     |      .. seealso::
     |      
     |          See the recipe on :ref:`attributes`.
     |      
     |      Example:
     |      
     |          .. testcode::
     |      
     |              import optuna
     |      
     |      
     |              def objective(trial):
     |                  x = trial.suggest_float("x", 0, 1)
     |                  y = trial.suggest_float("y", 0, 1)
     |                  return x**2 + y**2
     |      
     |      
     |              study = optuna.create_study()
     |      
     |              study.set_user_attr("objective function", "quadratic function")
     |              study.set_user_attr("dimensions", 2)
     |              study.set_user_attr("contributors", ["Akiba", "Sano"])
     |      
     |              assert study.user_attrs == {
     |                  "objective function": "quadratic function",
     |                  "dimensions": 2,
     |                  "contributors": ["Akiba", "Sano"],
     |              }
     |      
     |      Args:
     |          key: A key string of the attribute.
     |          value: A value of the attribute. The value should be JSON serializable.
     |  
     |  stop(self) -> 'None'
     |      Exit from the current optimization loop after the running trials finish.
     |      
     |      This method lets the running :meth:`~optuna.study.Study.optimize` method return
     |      immediately after all trials which the :meth:`~optuna.study.Study.optimize` method
     |      spawned finishes.
     |      This method does not affect any behaviors of parallel or successive study processes.
     |      This method only works when it is called inside an objective function or callback.
     |      
     |      Example:
     |      
     |          .. testcode::
     |      
     |              import optuna
     |      
     |      
     |              def objective(trial):
     |                  if trial.number == 4:
     |                      trial.study.stop()
     |                  x = trial.suggest_float("x", 0, 10)
     |                  return x**2
     |      
     |      
     |              study = optuna.create_study()
     |              study.optimize(objective, n_trials=10)
     |              assert len(study.trials) == 5
     |  
     |  tell(self, trial: 'trial_module.Trial | int', values: 'float | Sequence[float] | None' = None, state: 'TrialState | None' = None, skip_if_finished: 'bool' = False) -> 'FrozenTrial'
     |      Finish a trial created with :func:`~optuna.study.Study.ask`.
     |      
     |      .. seealso::
     |      
     |          The :ref:`ask_and_tell` tutorial provides use-cases with examples.
     |      
     |      Example:
     |      
     |          .. testcode::
     |      
     |              import optuna
     |              from optuna.trial import TrialState
     |      
     |      
     |              def f(x):
     |                  return (x - 2) ** 2
     |      
     |      
     |              def df(x):
     |                  return 2 * x - 4
     |      
     |      
     |              study = optuna.create_study()
     |      
     |              n_trials = 30
     |      
     |              for _ in range(n_trials):
     |                  trial = study.ask()
     |      
     |                  lr = trial.suggest_float("lr", 1e-5, 1e-1, log=True)
     |      
     |                  # Iterative gradient descent objective function.
     |                  x = 3  # Initial value.
     |                  for step in range(128):
     |                      y = f(x)
     |      
     |                      trial.report(y, step=step)
     |      
     |                      if trial.should_prune():
     |                          # Finish the trial with the pruned state.
     |                          study.tell(trial, state=TrialState.PRUNED)
     |                          break
     |      
     |                      gy = df(x)
     |                      x -= gy * lr
     |                  else:
     |                      # Finish the trial with the final value after all iterations.
     |                      study.tell(trial, y)
     |      
     |      Args:
     |          trial:
     |              A :class:`~optuna.trial.Trial` object or a trial number.
     |          values:
     |              Optional objective value or a sequence of such values in case the study is used
     |              for multi-objective optimization. Argument must be provided if ``state`` is
     |              :class:`~optuna.trial.TrialState.COMPLETE` and should be :obj:`None` if ``state``
     |              is :class:`~optuna.trial.TrialState.FAIL` or
     |              :class:`~optuna.trial.TrialState.PRUNED`.
     |          state:
     |              State to be reported. Must be :obj:`None`,
     |              :class:`~optuna.trial.TrialState.COMPLETE`,
     |              :class:`~optuna.trial.TrialState.FAIL` or
     |              :class:`~optuna.trial.TrialState.PRUNED`.
     |              If ``state`` is :obj:`None`,
     |              it will be updated to :class:`~optuna.trial.TrialState.COMPLETE`
     |              or :class:`~optuna.trial.TrialState.FAIL` depending on whether
     |              validation for ``values`` reported succeed or not.
     |          skip_if_finished:
     |              Flag to control whether exception should be raised when values for already
     |              finished trial are told. If :obj:`True`, tell is skipped without any error
     |              when the trial is already finished.
     |      
     |      Returns:
     |          A :class:`~optuna.trial.FrozenTrial` representing the resulting trial.
     |          A returned trial is deep copied thus user can modify it as needed.
     |  
     |  trials_dataframe(self, attrs: 'tuple[str, ...]' = ('number', 'value', 'datetime_start', 'datetime_complete', 'duration', 'params', 'user_attrs', 'system_attrs', 'state'), multi_index: 'bool' = False) -> "'pd.DataFrame'"
     |      Export trials as a pandas DataFrame_.
     |      
     |      The DataFrame_ provides various features to analyze studies. It is also useful to draw a
     |      histogram of objective values and to export trials as a CSV file.
     |      If there are no trials, an empty DataFrame_ is returned.
     |      
     |      Example:
     |      
     |          .. testcode::
     |      
     |              import optuna
     |              import pandas
     |      
     |      
     |              def objective(trial):
     |                  x = trial.suggest_float("x", -1, 1)
     |                  return x**2
     |      
     |      
     |              study = optuna.create_study()
     |              study.optimize(objective, n_trials=3)
     |      
     |              # Create a dataframe from the study.
     |              df = study.trials_dataframe()
     |              assert isinstance(df, pandas.DataFrame)
     |              assert df.shape[0] == 3  # n_trials.
     |      
     |      Args:
     |          attrs:
     |              Specifies field names of :class:`~optuna.trial.FrozenTrial` to include them to a
     |              DataFrame of trials.
     |          multi_index:
     |              Specifies whether the returned DataFrame_ employs MultiIndex_ or not. Columns that
     |              are hierarchical by nature such as ``(params, x)`` will be flattened to
     |              ``params_x`` when set to :obj:`False`.
     |      
     |      Returns:
     |          A pandas DataFrame_ of trials in the :class:`~optuna.study.Study`.
     |      
     |      .. _DataFrame: http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.html
     |      .. _MultiIndex: https://pandas.pydata.org/pandas-docs/stable/advanced.html
     |      
     |      Note:
     |          If ``value`` is in ``attrs`` during multi-objective optimization, it is implicitly
     |          replaced with ``values``.
     |      
     |      Note:
     |          If :meth:`~optuna.study.Study.set_metric_names` is called, the ``value`` or ``values``
     |          is implicitly replaced with the dictionary with the objective name as key and the
     |          objective value as value.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  best_params
     |      Return parameters of the best trial in the study.
     |      
     |      .. note::
     |          This feature can only be used for single-objective optimization.
     |      
     |      Returns:
     |          A dictionary containing parameters of the best trial.
     |  
     |  best_trial
     |      Return the best trial in the study.
     |      
     |      .. note::
     |          This feature can only be used for single-objective optimization.
     |          If your study is multi-objective,
     |          use :attr:`~optuna.study.Study.best_trials` instead.
     |      
     |      Returns:
     |          A :class:`~optuna.trial.FrozenTrial` object of the best trial.
     |      
     |      .. seealso::
     |          The :ref:`reuse_best_trial` tutorial provides a detailed example of how to use this
     |          method.
     |  
     |  best_trials
     |      Return trials located at the Pareto front in the study.
     |      
     |      A trial is located at the Pareto front if there are no trials that dominate the trial.
     |      It's called that a trial ``t0`` dominates another trial ``t1`` if
     |      ``all(v0 <= v1) for v0, v1 in zip(t0.values, t1.values)`` and
     |      ``any(v0 < v1) for v0, v1 in zip(t0.values, t1.values)`` are held.
     |      
     |      Returns:
     |          A list of :class:`~optuna.trial.FrozenTrial` objects.
     |  
     |  best_value
     |      Return the best objective value in the study.
     |      
     |      .. note::
     |          This feature can only be used for single-objective optimization.
     |      
     |      Returns:
     |          A float representing the best objective value.
     |  
     |  direction
     |      Return the direction of the study.
     |      
     |      .. note::
     |          This feature can only be used for single-objective optimization.
     |          If your study is multi-objective,
     |          use :attr:`~optuna.study.Study.directions` instead.
     |      
     |      Returns:
     |          A :class:`~optuna.study.StudyDirection` object.
     |  
     |  directions
     |      Return the directions of the study.
     |      
     |      Returns:
     |          A list of :class:`~optuna.study.StudyDirection` objects.
     |  
     |  metric_names
     |      Return metric names.
     |      
     |      .. note::
     |          Use :meth:`~optuna.study.Study.set_metric_names` to set the metric names first.
     |      
     |      Returns:
     |          A list with names for each dimension of the returned values of the objective function.
     |  
     |  system_attrs
     |      Return system attributes.
     |      
     |      Returns:
     |          A dictionary containing all system attributes.
     |      
     |      .. warning::
     |          Deprecated in v3.1.0. This feature will be removed in the future. The removal of this
     |          feature is currently scheduled for v5.0.0, but this schedule is subject to change.
     |          See https://github.com/optuna/optuna/releases/tag/v3.1.0.
     |  
     |  trials
     |      Return all trials in the study.
     |      
     |      The returned trials are ordered by trial number.
     |      
     |      This is a short form of ``self.get_trials(deepcopy=True, states=None)``.
     |      
     |      Returns:
     |          A list of :class:`~optuna.trial.FrozenTrial` objects.
     |      
     |          .. seealso::
     |              See :func:`~optuna.study.Study.get_trials` for related method.
     |  
     |  user_attrs
     |      Return user attributes.
     |      
     |      .. seealso::
     |      
     |          See :func:`~optuna.study.Study.set_user_attr` for related method.
     |      
     |      Example:
     |      
     |          .. testcode::
     |      
     |              import optuna
     |      
     |      
     |              def objective(trial):
     |                  x = trial.suggest_float("x", 0, 1)
     |                  y = trial.suggest_float("y", 0, 1)
     |                  return x**2 + y**2
     |      
     |      
     |              study = optuna.create_study()
     |      
     |              study.set_user_attr("objective function", "quadratic function")
     |              study.set_user_attr("dimensions", 2)
     |              study.set_user_attr("contributors", ["Akiba", "Sano"])
     |      
     |              assert study.user_attrs == {
     |                  "objective function": "quadratic function",
     |                  "dimensions": 2,
     |                  "contributors": ["Akiba", "Sano"],
     |              }
     |      
     |      Returns:
     |          A dictionary containing all user attributes.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Trial(optuna.trial._base.BaseTrial)
     |  Trial(study: "'optuna.study.Study'", trial_id: 'int') -> 'None'
     |  
     |  A trial is a process of evaluating an objective function.
     |  
     |  This object is passed to an objective function and provides interfaces to get parameter
     |  suggestion, manage the trial's state, and set/get user-defined attributes of the trial.
     |  
     |  Note that the direct use of this constructor is not recommended.
     |  This object is seamlessly instantiated and passed to the objective function behind
     |  the :func:`optuna.study.Study.optimize()` method; hence library users do not care about
     |  instantiation of this object.
     |  
     |  Args:
     |      study:
     |          A :class:`~optuna.study.Study` object.
     |      trial_id:
     |          A trial ID that is automatically generated.
     |  
     |  Method resolution order:
     |      Trial
     |      optuna.trial._base.BaseTrial
     |      abc.ABC
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, study: "'optuna.study.Study'", trial_id: 'int') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  report(self, value: 'float', step: 'int') -> 'None'
     |      Report an objective function value for a given step.
     |      
     |      The reported values are used by the pruners to determine whether this trial should be
     |      pruned.
     |      
     |      .. seealso::
     |          Please refer to :class:`~optuna.pruners.BasePruner`.
     |      
     |      .. note::
     |          The reported value is converted to ``float`` type by applying ``float()``
     |          function internally. Thus, it accepts all float-like types (e.g., ``numpy.float32``).
     |          If the conversion fails, a ``TypeError`` is raised.
     |      
     |      .. note::
     |          If this method is called multiple times at the same ``step`` in a trial,
     |          the reported ``value`` only the first time is stored and the reported values
     |          from the second time are ignored.
     |      
     |      .. note::
     |          :func:`~optuna.trial.Trial.report` does not support multi-objective
     |          optimization.
     |      
     |      Example:
     |      
     |          Report intermediate scores of `SGDClassifier <https://scikit-learn.org/stable/modules/
     |          generated/sklearn.linear_model.SGDClassifier.html>`_ training.
     |      
     |          .. testcode::
     |      
     |              import numpy as np
     |              from sklearn.datasets import load_iris
     |              from sklearn.linear_model import SGDClassifier
     |              from sklearn.model_selection import train_test_split
     |      
     |              import optuna
     |      
     |              X, y = load_iris(return_X_y=True)
     |              X_train, X_valid, y_train, y_valid = train_test_split(X, y)
     |      
     |      
     |              def objective(trial):
     |                  clf = SGDClassifier(random_state=0)
     |                  for step in range(100):
     |                      clf.partial_fit(X_train, y_train, np.unique(y))
     |                      intermediate_value = clf.score(X_valid, y_valid)
     |                      trial.report(intermediate_value, step=step)
     |                      if trial.should_prune():
     |                          raise optuna.TrialPruned()
     |      
     |                  return clf.score(X_valid, y_valid)
     |      
     |      
     |              study = optuna.create_study(direction="maximize")
     |              study.optimize(objective, n_trials=3)
     |      
     |      
     |      Args:
     |          value:
     |              A value returned from the objective function.
     |          step:
     |              Step of the trial (e.g., Epoch of neural network training). Note that pruners
     |              assume that ``step`` starts at zero. For example,
     |              :class:`~optuna.pruners.MedianPruner` simply checks if ``step`` is less than
     |              ``n_warmup_steps`` as the warmup mechanism.
     |              ``step`` must be a positive integer.
     |  
     |  set_system_attr(self, key: 'str', value: 'Any') -> 'None'
     |      Set system attributes to the trial.
     |      
     |      Note that Optuna internally uses this method to save system messages such as failure
     |      reason of trials. Please use :func:`~optuna.trial.Trial.set_user_attr` to set users'
     |      attributes.
     |      
     |      Args:
     |          key:
     |              A key string of the attribute.
     |          value:
     |              A value of the attribute. The value should be JSON serializable.
     |      
     |      .. warning::
     |          Deprecated in v3.1.0. This feature will be removed in the future. The removal of this
     |          feature is currently scheduled for v5.0.0, but this schedule is subject to change.
     |          See https://github.com/optuna/optuna/releases/tag/v3.1.0.
     |  
     |  set_user_attr(self, key: 'str', value: 'Any') -> 'None'
     |      Set user attributes to the trial.
     |      
     |      The user attributes in the trial can be access via :func:`optuna.trial.Trial.user_attrs`.
     |      
     |      .. seealso::
     |      
     |          See the recipe on :ref:`attributes`.
     |      
     |      Example:
     |      
     |          Save fixed hyperparameters of neural network training.
     |      
     |          .. testcode::
     |      
     |              import numpy as np
     |              from sklearn.datasets import load_iris
     |              from sklearn.model_selection import train_test_split
     |              from sklearn.neural_network import MLPClassifier
     |      
     |              import optuna
     |      
     |              X, y = load_iris(return_X_y=True)
     |              X_train, X_valid, y_train, y_valid = train_test_split(X, y, random_state=0)
     |      
     |      
     |              def objective(trial):
     |                  trial.set_user_attr("BATCHSIZE", 128)
     |                  momentum = trial.suggest_float("momentum", 0, 1.0)
     |                  clf = MLPClassifier(
     |                      hidden_layer_sizes=(100, 50),
     |                      batch_size=trial.user_attrs["BATCHSIZE"],
     |                      momentum=momentum,
     |                      solver="sgd",
     |                      random_state=0,
     |                  )
     |                  clf.fit(X_train, y_train)
     |      
     |                  return clf.score(X_valid, y_valid)
     |      
     |      
     |              study = optuna.create_study(direction="maximize")
     |              study.optimize(objective, n_trials=3)
     |              assert "BATCHSIZE" in study.best_trial.user_attrs.keys()
     |              assert study.best_trial.user_attrs["BATCHSIZE"] == 128
     |      
     |      
     |      Args:
     |          key:
     |              A key string of the attribute.
     |          value:
     |              A value of the attribute. The value should be JSON serializable.
     |  
     |  should_prune(self) -> 'bool'
     |      Suggest whether the trial should be pruned or not.
     |      
     |      The suggestion is made by a pruning algorithm associated with the trial and is based on
     |      previously reported values. The algorithm can be specified when constructing a
     |      :class:`~optuna.study.Study`.
     |      
     |      .. note::
     |          If no values have been reported, the algorithm cannot make meaningful suggestions.
     |          Similarly, if this method is called multiple times with the exact same set of reported
     |          values, the suggestions will be the same.
     |      
     |      .. seealso::
     |          Please refer to the example code in :func:`optuna.trial.Trial.report`.
     |      
     |      .. note::
     |          :func:`~optuna.trial.Trial.should_prune` does not support multi-objective
     |          optimization.
     |      
     |      Returns:
     |          A boolean value. If :obj:`True`, the trial should be pruned according to the
     |          configured pruning algorithm. Otherwise, the trial should continue.
     |  
     |  suggest_categorical(self, name: 'str', choices: 'Sequence[CategoricalChoiceType]') -> 'CategoricalChoiceType'
     |      Suggest a value for the categorical parameter.
     |      
     |      The value is sampled from ``choices``.
     |      
     |      Example:
     |      
     |          Suggest a kernel function of `SVC <https://scikit-learn.org/stable/modules/generated/
     |          sklearn.svm.SVC.html>`_.
     |      
     |          .. testcode::
     |      
     |              import numpy as np
     |              from sklearn.datasets import load_iris
     |              from sklearn.model_selection import train_test_split
     |              from sklearn.svm import SVC
     |      
     |              import optuna
     |      
     |              X, y = load_iris(return_X_y=True)
     |              X_train, X_valid, y_train, y_valid = train_test_split(X, y)
     |      
     |      
     |              def objective(trial):
     |                  kernel = trial.suggest_categorical("kernel", ["linear", "poly", "rbf"])
     |                  clf = SVC(kernel=kernel, gamma="scale", random_state=0)
     |                  clf.fit(X_train, y_train)
     |                  return clf.score(X_valid, y_valid)
     |      
     |      
     |              study = optuna.create_study(direction="maximize")
     |              study.optimize(objective, n_trials=3)
     |      
     |      
     |      Args:
     |          name:
     |              A parameter name.
     |          choices:
     |              Parameter value candidates.
     |      
     |      .. seealso::
     |          :class:`~optuna.distributions.CategoricalDistribution`.
     |      
     |      Returns:
     |          A suggested value.
     |      
     |      .. seealso::
     |          :ref:`configurations` tutorial describes more details and flexible usages.
     |  
     |  suggest_discrete_uniform(self, name: 'str', low: 'float', high: 'float', q: 'float') -> 'float'
     |      Suggest a value for the discrete parameter.
     |      
     |      The value is sampled from the range :math:`[\mathsf{low}, \mathsf{high}]`,
     |      and the step of discretization is :math:`q`. More specifically,
     |      this method returns one of the values in the sequence
     |      :math:`\mathsf{low}, \mathsf{low} + q, \mathsf{low} + 2 q, \dots,
     |      \mathsf{low} + k q \le \mathsf{high}`,
     |      where :math:`k` denotes an integer. Note that :math:`high` may be changed due to round-off
     |      errors if :math:`q` is not an integer. Please check warning messages to find the changed
     |      values.
     |      
     |      Args:
     |          name:
     |              A parameter name.
     |          low:
     |              Lower endpoint of the range of suggested values. ``low`` is included in the range.
     |          high:
     |              Upper endpoint of the range of suggested values. ``high`` is included in the range.
     |          q:
     |              A step of discretization.
     |      
     |      Returns:
     |          A suggested float value.
     |      
     |      .. warning::
     |          Deprecated in v3.0.0. This feature will be removed in the future. The removal of this
     |          feature is currently scheduled for v6.0.0, but this schedule is subject to change.
     |          See https://github.com/optuna/optuna/releases/tag/v3.0.0.
     |      
     |      
     |          Use suggest_float(..., step=...) instead.
     |  
     |  suggest_float(self, name: 'str', low: 'float', high: 'float', *, step: 'Optional[float]' = None, log: 'bool' = False) -> 'float'
     |      Suggest a value for the floating point parameter.
     |      
     |      Example:
     |      
     |          Suggest a momentum, learning rate and scaling factor of learning rate
     |          for neural network training.
     |      
     |          .. testcode::
     |      
     |              import numpy as np
     |              from sklearn.datasets import load_iris
     |              from sklearn.model_selection import train_test_split
     |              from sklearn.neural_network import MLPClassifier
     |      
     |              import optuna
     |      
     |              X, y = load_iris(return_X_y=True)
     |              X_train, X_valid, y_train, y_valid = train_test_split(X, y, random_state=0)
     |      
     |      
     |              def objective(trial):
     |                  momentum = trial.suggest_float("momentum", 0.0, 1.0)
     |                  learning_rate_init = trial.suggest_float(
     |                      "learning_rate_init", 1e-5, 1e-3, log=True
     |                  )
     |                  power_t = trial.suggest_float("power_t", 0.2, 0.8, step=0.1)
     |                  clf = MLPClassifier(
     |                      hidden_layer_sizes=(100, 50),
     |                      momentum=momentum,
     |                      learning_rate_init=learning_rate_init,
     |                      solver="sgd",
     |                      random_state=0,
     |                      power_t=power_t,
     |                  )
     |                  clf.fit(X_train, y_train)
     |      
     |                  return clf.score(X_valid, y_valid)
     |      
     |      
     |              study = optuna.create_study(direction="maximize")
     |              study.optimize(objective, n_trials=3)
     |      
     |      Args:
     |          name:
     |              A parameter name.
     |          low:
     |              Lower endpoint of the range of suggested values. ``low`` is included in the range.
     |              ``low`` must be less than or equal to ``high``. If ``log`` is :obj:`True`,
     |              ``low`` must be larger than 0.
     |          high:
     |              Upper endpoint of the range of suggested values. ``high`` is included in the range.
     |              ``high`` must be greater than or equal to ``low``.
     |          step:
     |              A step of discretization.
     |      
     |              .. note::
     |                  The ``step`` and ``log`` arguments cannot be used at the same time. To set
     |                  the ``step`` argument to a float number, set the ``log`` argument to
     |                  :obj:`False`.
     |          log:
     |              A flag to sample the value from the log domain or not.
     |              If ``log`` is true, the value is sampled from the range in the log domain.
     |              Otherwise, the value is sampled from the range in the linear domain.
     |      
     |              .. note::
     |                  The ``step`` and ``log`` arguments cannot be used at the same time. To set
     |                  the ``log`` argument to :obj:`True`, set the ``step`` argument to :obj:`None`.
     |      
     |      Returns:
     |          A suggested float value.
     |      
     |      .. seealso::
     |          :ref:`configurations` tutorial describes more details and flexible usages.
     |  
     |  suggest_int(self, name: 'str', low: 'int', high: 'int', *, step: 'int' = 1, log: 'bool' = False) -> 'int'
     |      Suggest a value for the integer parameter.
     |      
     |      The value is sampled from the integers in :math:`[\mathsf{low}, \mathsf{high}]`.
     |      
     |      Example:
     |      
     |          Suggest the number of trees in `RandomForestClassifier <https://scikit-learn.org/
     |          stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html>`_.
     |      
     |          .. testcode::
     |      
     |              import numpy as np
     |              from sklearn.datasets import load_iris
     |              from sklearn.ensemble import RandomForestClassifier
     |              from sklearn.model_selection import train_test_split
     |      
     |              import optuna
     |      
     |              X, y = load_iris(return_X_y=True)
     |              X_train, X_valid, y_train, y_valid = train_test_split(X, y)
     |      
     |      
     |              def objective(trial):
     |                  n_estimators = trial.suggest_int("n_estimators", 50, 400)
     |                  clf = RandomForestClassifier(n_estimators=n_estimators, random_state=0)
     |                  clf.fit(X_train, y_train)
     |                  return clf.score(X_valid, y_valid)
     |      
     |      
     |              study = optuna.create_study(direction="maximize")
     |              study.optimize(objective, n_trials=3)
     |      
     |      Args:
     |          name:
     |              A parameter name.
     |          low:
     |              Lower endpoint of the range of suggested values. ``low`` is included in the range.
     |              ``low`` must be less than or equal to ``high``. If ``log`` is :obj:`True`,
     |              ``low`` must be larger than 0.
     |          high:
     |              Upper endpoint of the range of suggested values. ``high`` is included in the range.
     |              ``high`` must be greater than or equal to ``low``.
     |          step:
     |              A step of discretization.
     |      
     |              .. note::
     |                  Note that :math:`\mathsf{high}` is modified if the range is not divisible by
     |                  :math:`\mathsf{step}`. Please check the warning messages to find the changed
     |                  values.
     |      
     |              .. note::
     |                  The method returns one of the values in the sequence
     |                  :math:`\mathsf{low}, \mathsf{low} + \mathsf{step}, \mathsf{low} + 2 *
     |                  \mathsf{step}, \dots, \mathsf{low} + k * \mathsf{step} \le
     |                  \mathsf{high}`, where :math:`k` denotes an integer.
     |      
     |              .. note::
     |                  The ``step != 1`` and ``log`` arguments cannot be used at the same time.
     |                  To set the ``step`` argument :math:`\mathsf{step} \ge 2`, set the
     |                  ``log`` argument to :obj:`False`.
     |          log:
     |              A flag to sample the value from the log domain or not.
     |      
     |              .. note::
     |                  If ``log`` is true, at first, the range of suggested values is divided into
     |                  grid points of width 1. The range of suggested values is then converted to
     |                  a log domain, from which a value is sampled. The uniformly sampled
     |                  value is re-converted to the original domain and rounded to the nearest grid
     |                  point that we just split, and the suggested value is determined.
     |                  For example, if `low = 2` and `high = 8`, then the range of suggested values is
     |                  `[2, 3, 4, 5, 6, 7, 8]` and lower values tend to be more sampled than higher
     |                  values.
     |      
     |              .. note::
     |                  The ``step != 1`` and ``log`` arguments cannot be used at the same time.
     |                  To set the ``log`` argument to :obj:`True`, set the ``step`` argument to 1.
     |      
     |      .. seealso::
     |          :ref:`configurations` tutorial describes more details and flexible usages.
     |  
     |  suggest_loguniform(self, name: 'str', low: 'float', high: 'float') -> 'float'
     |      Suggest a value for the continuous parameter.
     |      
     |      The value is sampled from the range :math:`[\mathsf{low}, \mathsf{high})`
     |      in the log domain. When :math:`\mathsf{low} = \mathsf{high}`, the value of
     |      :math:`\mathsf{low}` will be returned.
     |      
     |      Args:
     |          name:
     |              A parameter name.
     |          low:
     |              Lower endpoint of the range of suggested values. ``low`` is included in the range.
     |          high:
     |              Upper endpoint of the range of suggested values. ``high`` is included in the range.
     |      
     |      Returns:
     |          A suggested float value.
     |      
     |      .. warning::
     |          Deprecated in v3.0.0. This feature will be removed in the future. The removal of this
     |          feature is currently scheduled for v6.0.0, but this schedule is subject to change.
     |          See https://github.com/optuna/optuna/releases/tag/v3.0.0.
     |      
     |      
     |          Use suggest_float(..., log=True) instead.
     |  
     |  suggest_uniform(self, name: 'str', low: 'float', high: 'float') -> 'float'
     |      Suggest a value for the continuous parameter.
     |      
     |      The value is sampled from the range :math:`[\mathsf{low}, \mathsf{high})`
     |      in the linear domain. When :math:`\mathsf{low} = \mathsf{high}`, the value of
     |      :math:`\mathsf{low}` will be returned.
     |      
     |      Args:
     |          name:
     |              A parameter name.
     |          low:
     |              Lower endpoint of the range of suggested values. ``low`` is included in the range.
     |          high:
     |              Upper endpoint of the range of suggested values. ``high`` is included in the range.
     |      
     |      Returns:
     |          A suggested float value.
     |      
     |      .. warning::
     |          Deprecated in v3.0.0. This feature will be removed in the future. The removal of this
     |          feature is currently scheduled for v6.0.0, but this schedule is subject to change.
     |          See https://github.com/optuna/optuna/releases/tag/v3.0.0.
     |      
     |      
     |          Use suggest_float instead.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  datetime_start
     |      Return start datetime.
     |      
     |      Returns:
     |          Datetime where the :class:`~optuna.trial.Trial` started.
     |  
     |  distributions
     |      Return distributions of parameters to be optimized.
     |      
     |      Returns:
     |          A dictionary containing all distributions.
     |  
     |  number
     |      Return trial's number which is consecutive and unique in a study.
     |      
     |      Returns:
     |          A trial number.
     |  
     |  params
     |      Return parameters to be optimized.
     |      
     |      Returns:
     |          A dictionary containing all parameters.
     |  
     |  relative_params
     |  
     |  system_attrs
     |      Return system attributes.
     |      
     |      Returns:
     |          A dictionary containing all system attributes.
     |      
     |      .. warning::
     |          Deprecated in v3.1.0. This feature will be removed in the future. The removal of this
     |          feature is currently scheduled for v5.0.0, but this schedule is subject to change.
     |          See https://github.com/optuna/optuna/releases/tag/v3.1.0.
     |  
     |  user_attrs
     |      Return user attributes.
     |      
     |      Returns:
     |          A dictionary containing all user attributes.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from optuna.trial._base.BaseTrial:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class TrialPruned(OptunaError)
     |  Exception for pruned trials.
     |  
     |  This error tells a trainer that the current :class:`~optuna.trial.Trial` was pruned. It is
     |  supposed to be raised after :func:`optuna.trial.Trial.should_prune` as shown in the following
     |  example.
     |  
     |  See also:
     |      :class:`optuna.TrialPruned` is an alias of :class:`optuna.exceptions.TrialPruned`.
     |  
     |  Example:
     |  
     |      .. testcode::
     |  
     |          import numpy as np
     |          from sklearn.datasets import load_iris
     |          from sklearn.linear_model import SGDClassifier
     |          from sklearn.model_selection import train_test_split
     |  
     |          import optuna
     |  
     |          X, y = load_iris(return_X_y=True)
     |          X_train, X_valid, y_train, y_valid = train_test_split(X, y)
     |          classes = np.unique(y)
     |  
     |  
     |          def objective(trial):
     |              alpha = trial.suggest_float("alpha", 0.0, 1.0)
     |              clf = SGDClassifier(alpha=alpha)
     |              n_train_iter = 100
     |  
     |              for step in range(n_train_iter):
     |                  clf.partial_fit(X_train, y_train, classes=classes)
     |  
     |                  intermediate_value = clf.score(X_valid, y_valid)
     |                  trial.report(intermediate_value, step)
     |  
     |                  if trial.should_prune():
     |                      raise optuna.TrialPruned()
     |  
     |              return clf.score(X_valid, y_valid)
     |  
     |  
     |          study = optuna.create_study(direction="maximize")
     |          study.optimize(objective, n_trials=20)
     |  
     |  Method resolution order:
     |      TrialPruned
     |      OptunaError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors inherited from OptunaError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  add_note(...)
     |      Exception.add_note(note) --
     |      add a note to the exception
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args

FUNCTIONS
    copy_study(*, from_study_name: 'str', from_storage: 'str | storages.BaseStorage', to_storage: 'str | storages.BaseStorage', to_study_name: 'str | None' = None) -> 'None'
        Copy study from one storage to another.
        
        The direction(s) of the objective(s) in the study, trials, user attributes and system
        attributes are copied.
        
        .. note::
            :func:`~optuna.copy_study` copies a study even if the optimization is working on.
            It means users will get a copied study that contains a trial that is not finished.
        
        Example:
        
            .. testsetup::
        
                import os
        
                if os.path.exists("example.db"):
                    raise RuntimeError("'example.db' already exists. Please remove it.")
                if os.path.exists("example_copy.db"):
                    raise RuntimeError("'example_copy.db' already exists. Please remove it.")
        
            .. testcode::
        
                import optuna
        
        
                def objective(trial):
                    x = trial.suggest_float("x", -10, 10)
                    return (x - 2) ** 2
        
        
                study = optuna.create_study(
                    study_name="example-study",
                    storage="sqlite:///example.db",
                )
                study.optimize(objective, n_trials=3)
        
                optuna.copy_study(
                    from_study_name="example-study",
                    from_storage="sqlite:///example.db",
                    to_storage="sqlite:///example_copy.db",
                )
        
                study = optuna.load_study(
                    study_name=None,
                    storage="sqlite:///example_copy.db",
                )
        
            .. testcleanup::
        
                os.remove("example.db")
                os.remove("example_copy.db")
        
        Args:
            from_study_name:
                Name of study.
            from_storage:
                Source database URL such as ``sqlite:///example.db``. Please see also the
                documentation of :func:`~optuna.study.create_study` for further details.
            to_storage:
                Destination database URL.
            to_study_name:
                Name of the created study. If omitted, ``from_study_name`` is used.
        
        Raises:
            :class:`~optuna.exceptions.DuplicatedStudyError`:
                If a study with a conflicting name already exists in the destination storage.
    
    create_study(*, storage: 'str | storages.BaseStorage | None' = None, sampler: "'samplers.BaseSampler' | None" = None, pruner: 'pruners.BasePruner | None' = None, study_name: 'str | None' = None, direction: 'str | StudyDirection | None' = None, load_if_exists: 'bool' = False, directions: 'Sequence[str | StudyDirection] | None' = None) -> 'Study'
        Create a new :class:`~optuna.study.Study`.
        
        Example:
        
            .. testcode::
        
                import optuna
        
        
                def objective(trial):
                    x = trial.suggest_float("x", 0, 10)
                    return x**2
        
        
                study = optuna.create_study()
                study.optimize(objective, n_trials=3)
        
        Args:
            storage:
                Database URL. If this argument is set to None, in-memory storage is used, and the
                :class:`~optuna.study.Study` will not be persistent.
        
                .. note::
                    When a database URL is passed, Optuna internally uses `SQLAlchemy`_ to handle
                    the database. Please refer to `SQLAlchemy's document`_ for further details.
                    If you want to specify non-default options to `SQLAlchemy Engine`_, you can
                    instantiate :class:`~optuna.storages.RDBStorage` with your desired options and
                    pass it to the ``storage`` argument instead of a URL.
        
                 .. _SQLAlchemy: https://www.sqlalchemy.org/
                 .. _SQLAlchemy's document:
                     https://docs.sqlalchemy.org/en/latest/core/engines.html#database-urls
                 .. _SQLAlchemy Engine: https://docs.sqlalchemy.org/en/latest/core/engines.html
        
            sampler:
                A sampler object that implements background algorithm for value suggestion.
                If :obj:`None` is specified, :class:`~optuna.samplers.TPESampler` is used during
                single-objective optimization and :class:`~optuna.samplers.NSGAIISampler` during
                multi-objective optimization. See also :class:`~optuna.samplers`.
            pruner:
                A pruner object that decides early stopping of unpromising trials. If :obj:`None`
                is specified, :class:`~optuna.pruners.MedianPruner` is used as the default. See
                also :class:`~optuna.pruners`.
            study_name:
                Study's name. If this argument is set to None, a unique name is generated
                automatically.
            direction:
                Direction of optimization. Set ``minimize`` for minimization and ``maximize`` for
                maximization. You can also pass the corresponding :class:`~optuna.study.StudyDirection`
                object. ``direction`` and ``directions`` must not be specified at the same time.
        
                .. note::
                    If none of `direction` and `directions` are specified, the direction of the study
                    is set to "minimize".
            load_if_exists:
                Flag to control the behavior to handle a conflict of study names.
                In the case where a study named ``study_name`` already exists in the ``storage``,
                a :class:`~optuna.exceptions.DuplicatedStudyError` is raised if ``load_if_exists`` is
                set to :obj:`False`.
                Otherwise, the creation of the study is skipped, and the existing one is returned.
            directions:
                A sequence of directions during multi-objective optimization.
                ``direction`` and ``directions`` must not be specified at the same time.
        
        Returns:
            A :class:`~optuna.study.Study` object.
        
        See also:
            :func:`optuna.create_study` is an alias of :func:`optuna.study.create_study`.
        
        See also:
            The :ref:`rdb` tutorial provides concrete examples to save and resume optimization using
            RDB.
    
    create_trial(*, state: optuna.trial._state.TrialState = 1, value: Optional[float] = None, values: Optional[Sequence[float]] = None, params: Optional[Dict[str, Any]] = None, distributions: Optional[Dict[str, optuna.distributions.BaseDistribution]] = None, user_attrs: Optional[Dict[str, Any]] = None, system_attrs: Optional[Dict[str, Any]] = None, intermediate_values: Optional[Dict[int, float]] = None) -> optuna.trial._frozen.FrozenTrial
        Create a new :class:`~optuna.trial.FrozenTrial`.
        
        Example:
        
            .. testcode::
        
                import optuna
                from optuna.distributions import CategoricalDistribution
                from optuna.distributions import FloatDistribution
        
                trial = optuna.trial.create_trial(
                    params={"x": 1.0, "y": 0},
                    distributions={
                        "x": FloatDistribution(0, 10),
                        "y": CategoricalDistribution([-1, 0, 1]),
                    },
                    value=5.0,
                )
        
                assert isinstance(trial, optuna.trial.FrozenTrial)
                assert trial.value == 5.0
                assert trial.params == {"x": 1.0, "y": 0}
        
        .. seealso::
        
            See :func:`~optuna.study.Study.add_trial` for how this function can be used to create a
            study from existing trials.
        
        .. note::
        
            Please note that this is a low-level API. In general, trials that are passed to objective
            functions are created inside :func:`~optuna.study.Study.optimize`.
        
        .. note::
            When ``state`` is :class:`TrialState.COMPLETE`, the following parameters are
            required:
        
            * ``params``
            * ``distributions``
            * ``value`` or ``values``
        
        Args:
            state:
                Trial state.
            value:
                Trial objective value. Must be specified if ``state`` is :class:`TrialState.COMPLETE`.
                ``value`` and ``values`` must not be specified at the same time.
            values:
                Sequence of the trial objective values. The length is greater than 1 if the problem is
                multi-objective optimization.
                Must be specified if ``state`` is :class:`TrialState.COMPLETE`.
                ``value`` and ``values`` must not be specified at the same time.
            params:
                Dictionary with suggested parameters of the trial.
            distributions:
                Dictionary with parameter distributions of the trial.
            user_attrs:
                Dictionary with user attributes.
            system_attrs:
                Dictionary with system attributes. Should not have to be used for most users.
            intermediate_values:
                Dictionary with intermediate objective values of the trial.
        
        Returns:
            Created trial.
    
    delete_study(*, study_name: 'str', storage: 'str | storages.BaseStorage') -> 'None'
        Delete a :class:`~optuna.study.Study` object.
        
        Example:
        
            .. testsetup::
        
                import os
        
                if os.path.exists("example.db"):
                    raise RuntimeError("'example.db' already exists. Please remove it.")
        
            .. testcode::
        
                import optuna
        
        
                def objective(trial):
                    x = trial.suggest_float("x", -10, 10)
                    return (x - 2) ** 2
        
        
                study = optuna.create_study(study_name="example-study", storage="sqlite:///example.db")
                study.optimize(objective, n_trials=3)
        
                optuna.delete_study(study_name="example-study", storage="sqlite:///example.db")
        
            .. testcleanup::
        
                os.remove("example.db")
        
        Args:
            study_name:
                Study's name.
            storage:
                Database URL such as ``sqlite:///example.db``. Please see also the documentation of
                :func:`~optuna.study.create_study` for further details.
        
        See also:
            :func:`optuna.delete_study` is an alias of :func:`optuna.study.delete_study`.
    
    get_all_study_names(storage: 'str | storages.BaseStorage') -> 'list[str]'
        Get all study names stored in a specified storage.
        
        Example:
        
            .. testsetup::
        
                import os
        
                if os.path.exists("example.db"):
                    raise RuntimeError("'example.db' already exists. Please remove it.")
        
            .. testcode::
        
                import optuna
        
        
                def objective(trial):
                    x = trial.suggest_float("x", -10, 10)
                    return (x - 2) ** 2
        
        
                study = optuna.create_study(study_name="example-study", storage="sqlite:///example.db")
                study.optimize(objective, n_trials=3)
        
                study_names = optuna.study.get_all_study_names(storage="sqlite:///example.db")
                assert len(study_names) == 1
        
                assert study_names[0] == "example-study"
        
            .. testcleanup::
        
                os.remove("example.db")
        
        Args:
            storage:
                Database URL such as ``sqlite:///example.db``. Please see also the documentation of
                :func:`~optuna.study.create_study` for further details.
        
        Returns:
            List of all study names in the storage.
        
        See also:
            :func:`optuna.get_all_study_names` is an alias of
            :func:`optuna.study.get_all_study_names`.
    
    get_all_study_summaries(storage: 'str | storages.BaseStorage', include_best_trial: 'bool' = True) -> 'list[StudySummary]'
        Get all history of studies stored in a specified storage.
        
        Example:
        
            .. testsetup::
        
                import os
        
                if os.path.exists("example.db"):
                    raise RuntimeError("'example.db' already exists. Please remove it.")
        
            .. testcode::
        
                import optuna
        
        
                def objective(trial):
                    x = trial.suggest_float("x", -10, 10)
                    return (x - 2) ** 2
        
        
                study = optuna.create_study(study_name="example-study", storage="sqlite:///example.db")
                study.optimize(objective, n_trials=3)
        
                study_summaries = optuna.study.get_all_study_summaries(storage="sqlite:///example.db")
                assert len(study_summaries) == 1
        
                study_summary = study_summaries[0]
                assert study_summary.study_name == "example-study"
        
            .. testcleanup::
        
                os.remove("example.db")
        
        Args:
            storage:
                Database URL such as ``sqlite:///example.db``. Please see also the documentation of
                :func:`~optuna.study.create_study` for further details.
            include_best_trial:
                Include the best trials if exist. It potentially increases the number of queries and
                may take longer to fetch summaries depending on the storage.
        
        Returns:
            List of study history summarized as :class:`~optuna.study.StudySummary` objects.
        
        See also:
            :func:`optuna.get_all_study_summaries` is an alias of
            :func:`optuna.study.get_all_study_summaries`.
    
    load_study(*, study_name: 'str | None', storage: 'str | storages.BaseStorage', sampler: "'samplers.BaseSampler' | None" = None, pruner: 'pruners.BasePruner | None' = None) -> 'Study'
        Load the existing :class:`~optuna.study.Study` that has the specified name.
        
        Example:
        
            .. testsetup::
        
                import os
        
                if os.path.exists("example.db"):
                    raise RuntimeError("'example.db' already exists. Please remove it.")
        
            .. testcode::
        
                import optuna
        
        
                def objective(trial):
                    x = trial.suggest_float("x", 0, 10)
                    return x**2
        
        
                study = optuna.create_study(storage="sqlite:///example.db", study_name="my_study")
                study.optimize(objective, n_trials=3)
        
                loaded_study = optuna.load_study(study_name="my_study", storage="sqlite:///example.db")
                assert len(loaded_study.trials) == len(study.trials)
        
            .. testcleanup::
        
                os.remove("example.db")
        
        Args:
            study_name:
                Study's name. Each study has a unique name as an identifier. If :obj:`None`, checks
                whether the storage contains a single study, and if so loads that study.
                ``study_name`` is required if there are multiple studies in the storage.
            storage:
                Database URL such as ``sqlite:///example.db``. Please see also the documentation of
                :func:`~optuna.study.create_study` for further details.
            sampler:
                A sampler object that implements background algorithm for value suggestion.
                If :obj:`None` is specified, :class:`~optuna.samplers.TPESampler` is used
                as the default. See also :class:`~optuna.samplers`.
            pruner:
                A pruner object that decides early stopping of unpromising trials.
                If :obj:`None` is specified, :class:`~optuna.pruners.MedianPruner` is used
                as the default. See also :class:`~optuna.pruners`.
        
        See also:
            :func:`optuna.load_study` is an alias of :func:`optuna.study.load_study`.

DATA
    __all__ = ['Study', 'Trial', 'TrialPruned', '__version__', 'artifacts'...

VERSION
    3.5.0

FILE
    /home/ahoope5/anaconda3/envs/gym/lib/python3.11/site-packages/optuna/__init__.py


